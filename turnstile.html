<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>人机验证组件</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        .turnstile-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .turnstile-modal {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            width: 350px;
            overflow: hidden;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .turnstile-header {
            background-color: #f5f5f5;
            padding: 16px;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
        }

        .turnstile-body {
            padding: 24px;
            text-align: center;
        }

        .turnstile-logo {
            width: 40px;
            height: 40px;
            margin-bottom: 16px;
            background-color: #f38020;
            border-radius: 50%;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
        }

        .turnstile-message {
            margin-bottom: 20px;
            color: #333;
            font-size: 16px;
        }

        .turnstile-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 16px;
            text-align: center;
        }

        .turnstile-button {
            background-color: #f38020;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
            width: 100%;
        }

        .turnstile-button:hover {
            background-color: #e6731b;
        }

        .turnstile-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .turnstile-footer {
            padding: 12px;
            text-align: center;
            font-size: 12px;
            color: #999;
            border-top: 1px solid #e0e0e0;
        }

        .turnstile-success {
            color: #4CAF50;
            font-weight: bold;
            margin-top: 16px;
            display: none;
        }

        .turnstile-error {
            color: #f44336;
            font-size: 14px;
            margin-top: 12px;
            display: none;
        }

        .turnstile-loading {
            display: none;
            margin: 16px auto;
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #f38020;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .turnstile-behavior-data {
            display: none;
        }
    </style>
</head>

<body>
    <div class="turnstile-modal">
        <div class="turnstile-header">
            <div class="turnstile-logo">✓</div>
            <h3>人机验证</h3>
        </div>
        <div class="turnstile-body">
            <p class="turnstile-message">请确认您不是机器人</p>
            <input type="text" class="turnstile-input" id="humanInput" placeholder="输入“我不是机器人”以验证" />
            <button class="turnstile-button" id="verifyButton">验证</button>
            <div class="turnstile-loading" id="loadingIndicator"></div>
            <p class="turnstile-success" id="successMessage">验证成功！正在加载内容...</p>
            <p class="turnstile-error" id="errorMessage">验证失败，请重试</p>
            <div class="turnstile-behavior-data" id="behaviorData"></div>
        </div>
        <div class="turnstile-footer">
            由安全验证系统提供保护
        </div>
    </div>

    <script>
        // 主验证类
        class TurnstileVerification {
            constructor() {
                this.behaviorScore = 0;
                this.maxScore = 100;
                this.passingScore = 75;
                this.verificationPassed = false;
                this.behaviorData = {
                    mouseMovements: [],
                    clicks: [],
                    scrolls: [],
                    keyPresses: [],
                    deviceInfo: {},
                    networkRequests: []
                };

                this.initElements();
                this.setupEventListeners();
                this.collectDeviceFingerprint();
                this.monitorNetworkRequests();

                // 尝试无感验证
                setTimeout(() => this.tryPassiveVerification(), 2000);
            }

            initElements() {
                this.humanInput = document.getElementById('humanInput');
                this.verifyButton = document.getElementById('verifyButton');
                this.loadingIndicator = document.getElementById('loadingIndicator');
                this.successMessage = document.getElementById('successMessage');
                this.errorMessage = document.getElementById('errorMessage');
                this.behaviorDataElement = document.getElementById('behaviorData');
            }

            setupEventListeners() {
                // 鼠标移动跟踪
                document.addEventListener('mousemove', (e) => {
                    this.recordMouseMovement(e);
                });

                // 点击跟踪
                document.addEventListener('click', (e) => {
                    this.recordClick(e);
                });

                // 滚动跟踪
                window.addEventListener('scroll', (e) => {
                    this.recordScroll(e);
                }, true);

                // 键盘输入跟踪
                document.addEventListener('keydown', (e) => {
                    this.recordKeyPress(e);
                });

                // 验证按钮点击
                this.verifyButton.addEventListener('click', () => {
                    this.verifyHuman();
                });

                // 输入框输入验证
                this.humanInput.addEventListener('input', () => {
                    if (this.humanInput.value === "我不是机器人") {
                        this.behaviorScore += 10; // 正确输入加分
                    } else {
                        this.behaviorScore -= 15; // 错误输入减分
                    }
                });
            }

            // 行为分析方法
            recordMouseMovement(e) {
                const now = Date.now();
                const movement = {
                    x: e.clientX,
                    y: e.clientY,
                    time: now,
                    speed: 0,
                    acceleration: 0
                };

                if (this.behaviorData.mouseMovements.length > 0) {
                    const last = this.behaviorData.mouseMovements[this.behaviorData.mouseMovements.length - 1];
                    const timeDiff = (now - last.time) / 1000;
                    if (timeDiff > 0) {
                        const distance = Math.sqrt(
                            Math.pow(movement.x - last.x, 2) +
                            Math.pow(movement.y - last.y, 2)
                        );
                        movement.speed = distance / timeDiff;

                        if (this.behaviorData.mouseMovements.length > 1) {
                            const lastSpeed = last.speed;
                            movement.acceleration = (movement.speed - lastSpeed) / timeDiff;
                        }
                    }
                }

                this.behaviorData.mouseMovements.push(movement);

                // 分析鼠标轨迹
                this.analyzeMouseBehavior();
            }

            recordClick(e) {
                const now = Date.now();
                const click = {
                    x: e.clientX,
                    y: e.clientY,
                    time: now
                };

                if (this.behaviorData.clicks.length > 0) {
                    const lastClick = this.behaviorData.clicks[this.behaviorData.clicks.length - 1];
                    click.interval = now - lastClick.time;
                }

                this.behaviorData.clicks.push(click);

                // 分析点击模式
                this.analyzeClickPattern();
            }

            recordScroll(e) {
                const now = Date.now();
                const scroll = {
                    position: window.scrollY,
                    time: now,
                    speed: 0
                };

                if (this.behaviorData.scrolls.length > 0) {
                    const lastScroll = this.behaviorData.scrolls[this.behaviorData.scrolls.length - 1];
                    const timeDiff = (now - lastScroll.time) / 1000;
                    if (timeDiff > 0) {
                        scroll.speed = Math.abs(scroll.position - lastScroll.position) / timeDiff;
                    }
                }

                this.behaviorData.scrolls.push(scroll);

                // 分析滚动行为
                this.analyzeScrollBehavior();
            }

            recordKeyPress(e) {
                const now = Date.now();
                const keyPress = {
                    key: e.key,
                    code: e.code,
                    time: now,
                    interval: 0
                };

                if (this.behaviorData.keyPresses.length > 0) {
                    const lastKeyPress = this.behaviorData.keyPresses[this.behaviorData.keyPresses.length - 1];
                    keyPress.interval = now - lastKeyPress.time;
                }

                this.behaviorData.keyPresses.push(keyPress);

                // 分析键盘输入模式
                this.analyzeTypingPattern();
            }

            // 行为分析方法
            analyzeMouseBehavior() {
                const movements = this.behaviorData.mouseMovements;
                if (movements.length < 3) return;

                // 检查鼠标速度变化
                const speedVariation = this.calculateVariation(movements.map(m => m.speed));
                if (speedVariation > 0.5) {
                    this.behaviorScore += 5; // 人类鼠标移动速度变化较大
                }

                // 检查加速度模式
                const accelerationPattern = this.detectPattern(movements.map(m => m.acceleration));
                if (accelerationPattern.regularity < 0.3) {
                    this.behaviorScore += 5; // 人类鼠标加速度不规则
                }

                // 检查轨迹直线性
                const linearity = this.checkMovementLinearity(movements.slice(-20));
                if (linearity < 0.7) {
                    this.behaviorScore += 5; // 人类鼠标轨迹不完全是直线
                }
            }

            analyzeClickPattern() {
                const clicks = this.behaviorData.clicks;
                if (clicks.length < 3) return;

                // 检查点击间隔变化
                const intervals = clicks.map((c, i) => i > 0 ? c.interval : 0).filter(i => i > 0);
                const intervalVariation = this.calculateVariation(intervals);
                if (intervalVariation > 0.4) {
                    this.behaviorScore += 5; // 人类点击间隔变化较大
                }

                // 检查点击位置分布
                const positionVariance = this.calculatePositionVariance(clicks.map(c => ({ x: c.x, y: c.y })));
                if (positionVariance > 10000) {
                    this.behaviorScore += 5; // 人类点击位置分散
                }
            }

            analyzeScrollBehavior() {
                const scrolls = this.behaviorData.scrolls;
                if (scrolls.length < 3) return;

                // 检查滚动速度变化
                const speedVariation = this.calculateVariation(scrolls.map(s => s.speed));
                if (speedVariation > 0.6) {
                    this.behaviorScore += 5; // 人类滚动速度变化较大
                }

                // 检查滚动方向变化
                const directionChanges = this.countDirectionChanges(scrolls);
                if (directionChanges > scrolls.length * 0.3) {
                    this.behaviorScore += 5; // 人类经常改变滚动方向
                }
            }

            analyzeTypingPattern() {
                const keyPresses = this.behaviorData.keyPresses;
                if (keyPresses.length < 3) return;

                // 检查输入间隔变化
                const intervals = keyPresses.map((k, i) => i > 0 ? k.interval : 0).filter(i => i > 0);
                const intervalVariation = this.calculateVariation(intervals);
                if (intervalVariation > 0.5) {
                    this.behaviorScore += 5; // 人类输入间隔变化较大
                }

                // 检查常见的人类输入错误和修正
                const corrections = this.detectTypingCorrections(keyPresses);
                if (corrections > 0) {
                    this.behaviorScore += corrections * 2; // 人类会犯输入错误并修正
                }
            }

            // 设备指纹收集
            collectDeviceFingerprint() {
                this.behaviorData.deviceInfo = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
                    deviceMemory: navigator.deviceMemory || 'unknown',
                    screenResolution: `${window.screen.width}x${window.screen.height}`,
                    colorDepth: window.screen.colorDepth,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    languages: navigator.languages,
                    cookieEnabled: navigator.cookieEnabled,
                    doNotTrack: navigator.doNotTrack || 'unspecified',
                    webglVendor: this.getWebGLInfo(),
                    canvasFingerprint: this.getCanvasFingerprint(),
                    audioContextFingerprint: this.getAudioContextFingerprint(),
                    fonts: this.detectInstalledFonts(),
                    plugins: this.getBrowserPlugins(),
                    touchSupport: 'ontouchstart' in window,
                    batteryApi: 'getBattery' in navigator
                };

                // 分析设备指纹
                this.analyzeDeviceFingerprint();
            }

            getWebGLInfo() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (!gl) return 'unsupported';

                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    return {
                        vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                        renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
                    };
                } catch (e) {
                    return 'error';
                }
            }

            getCanvasFingerprint() {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 200;
                    canvas.height = 50;

                    // 绘制一些文本和形状
                    ctx.textBaseline = 'top';
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#f60';
                    ctx.fillRect(0, 0, 50, 50);
                    ctx.fillStyle = '#069';
                    ctx.fillText('Canvas Fingerprint', 60, 15);

                    // 添加复杂形状
                    ctx.strokeStyle = 'rgb(120, 186, 176)';
                    ctx.beginPath();
                    ctx.moveTo(60, 30);
                    ctx.lineTo(120, 30);
                    ctx.lineTo(120, 40);
                    ctx.lineTo(60, 40);
                    ctx.closePath();
                    ctx.stroke();

                    return canvas.toDataURL().slice(-32); // 取部分数据作为指纹
                } catch (e) {
                    return 'error';
                }
            }

            getAudioContextFingerprint() {
                try {
                    if (!window.AudioContext && !window.webkitAudioContext) return 'unsupported';

                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const analyser = audioContext.createAnalyser();
                    const gainNode = audioContext.createGain();
                    const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);

                    oscillator.type = 'triangle';
                    oscillator.connect(analyser);
                    analyser.connect(scriptProcessor);
                    scriptProcessor.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.start(0);

                    const audioData = new Float32Array(analyser.frequencyBinCount);
                    analyser.getFloatFrequencyData(audioData);

                    oscillator.stop();
                    audioContext.close();

                    // 计算音频指纹
                    let hash = 0;
                    for (let i = 0; i < audioData.length; i++) {
                        hash += Math.abs(audioData[i]);
                    }

                    return hash.toString(16).slice(0, 8);
                } catch (e) {
                    return 'error';
                }
            }

            detectInstalledFonts() {
                const fontList = [
                    'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',
                    'Georgia', 'Impact', 'Times New Roman', 'Trebuchet MS',
                    'Verdana', 'Microsoft YaHei', 'SimSun', 'SimHei',
                    'KaiTi', 'FangSong', 'STXihei', 'STKaiti', 'STSong',
                    'STFangsong', 'Andale Mono', 'Baskerville'
                ];

                const detectedFonts = [];
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 50;

                // 使用基线测试法检测字体
                const baselineText = 'mmmmmmmmmmlli';
                const referenceWidths = {};

                // 首先测量默认字体的宽度
                context.font = '72px monospace';
                referenceWidths['monospace'] = context.measureText(baselineText).width;

                // 测试每种字体
                fontList.forEach(font => {
                    context.font = `72px "${font}", monospace`;
                    const width = context.measureText(baselineText).width;

                    if (width !== referenceWidths['monospace']) {
                        detectedFonts.push(font);
                    }
                });

                return detectedFonts;
            }

            getBrowserPlugins() {
                const plugins = [];
                if (navigator.plugins) {
                    for (let i = 0; i < navigator.plugins.length; i++) {
                        plugins.push(navigator.plugins[i].name);
                    }
                }
                return plugins;
            }

            analyzeDeviceFingerprint() {
                // 检查常见自动化工具的指纹特征
                const ua = this.behaviorData.deviceInfo.userAgent.toLowerCase();

                // 检查Headless浏览器
                if (ua.includes('headless') ||
                    ua.includes('phantom') ||
                    ua.includes('puppeteer') ||
                    ua.includes('selenium') ||
                    !this.behaviorData.deviceInfo.webglVendor ||
                    this.behaviorData.deviceInfo.webglVendor === 'error') {
                    this.behaviorScore -= 20; // 可能是自动化工具
                } else {
                    this.behaviorScore += 10; // 正常浏览器指纹
                }

                // 检查字体数量异常
                if (this.behaviorData.deviceInfo.fonts.length < 3) {
                    this.behaviorScore -= 10; // 字体太少可能是自动化环境
                }

                // 检查插件数量异常
                if (this.behaviorData.deviceInfo.plugins.length === 0 &&
                    navigator.plugins && navigator.plugins.length === 0) {
                    this.behaviorScore -= 5; // 无插件可能是自动化环境
                }
            }

            // 网络请求监控
            monitorNetworkRequests() {
                const originalFetch = window.fetch;
                const originalXHROpen = XMLHttpRequest.prototype.open;
                const originalXHRSend = XMLHttpRequest.prototype.send;

                // 拦截fetch请求
                window.fetch = async (...args) => {
                    const startTime = Date.now();
                    try {
                        const response = await originalFetch(...args);
                        this.recordNetworkRequest({
                            type: 'fetch',
                            url: args[0],
                            method: args[1]?.method || 'GET',
                            startTime,
                            endTime: Date.now(),
                            status: response.status
                        });
                        return response;
                    } catch (error) {
                        this.recordNetworkRequest({
                            type: 'fetch',
                            url: args[0],
                            method: args[1]?.method || 'GET',
                            startTime,
                            endTime: Date.now(),
                            status: 'error',
                            error: error.message
                        });
                        throw error;
                    }
                };

                // 拦截XMLHttpRequest
                XMLHttpRequest.prototype.open = function (method, url) {
                    this._requestDetails = {
                        method,
                        url,
                        startTime: Date.now()
                    };
                    return originalXHROpen.apply(this, arguments);
                };

                XMLHttpRequest.prototype.send = function (body) {
                    const xhr = this;
                    const details = xhr._requestDetails;

                    xhr.addEventListener('load', function () {
                        details.endTime = Date.now();
                        details.status = xhr.status;
                        this.recordNetworkRequest(details);
                    }.bind(this));

                    xhr.addEventListener('error', function () {
                        details.endTime = Date.now();
                        details.status = 'error';
                        details.error = 'Request failed';
                        this.recordNetworkRequest(details);
                    }.bind(this));

                    return originalXHRSend.apply(xhr, arguments);
                };
            }

            recordNetworkRequest(request) {
                this.behaviorData.networkRequests.push(request);

                // 分析请求模式
                if (this.behaviorData.networkRequests.length > 3) {
                    this.analyzeNetworkPatterns();
                }
            }

            analyzeNetworkPatterns() {
                const requests = this.behaviorData.networkRequests;

                // 检查请求时间间隔
                const intervals = [];
                for (let i = 1; i < requests.length; i++) {
                    intervals.push(requests[i].startTime - requests[i - 1].endTime);
                }

                const intervalVariation = this.calculateVariation(intervals);
                if (intervalVariation < 0.3) {
                    this.behaviorScore -= 10; // 请求间隔过于规律可能是自动化脚本
                }

                // 检查请求URL多样性
                const uniqueUrls = [...new Set(requests.map(r => r.url))].length;
                if (uniqueUrls < requests.length * 0.3 && requests.length > 5) {
                    this.behaviorScore -= 5; // URL多样性不足可能是爬虫
                }
            }

            // 辅助分析方法
            calculateVariation(values) {
                if (values.length < 2) return 0;

                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
                return Math.sqrt(variance) / mean;
            }

            calculatePositionVariance(positions) {
                if (positions.length < 2) return 0;

                const meanX = positions.reduce((a, b) => a + b.x, 0) / positions.length;
                const meanY = positions.reduce((a, b) => a + b.y, 0) / positions.length;

                const varianceX = positions.reduce((a, b) => a + Math.pow(b.x - meanX, 2), 0) / positions.length;
                const varianceY = positions.reduce((a, b) => a + Math.pow(b.y - meanY, 2), 0) / positions.length;

                return varianceX + varianceY;
            }

            countDirectionChanges(scrolls) {
                let changes = 0;
                let lastDirection = 0;

                for (let i = 1; i < scrolls.length; i++) {
                    const direction = Math.sign(scrolls[i].position - scrolls[i - 1].position);
                    if (direction !== 0 && direction !== lastDirection) {
                        changes++;
                        lastDirection = direction;
                    }
                }

                return changes;
            }

            detectPattern(values) {
                const diffs = [];
                for (let i = 1; i < values.length; i++) {
                    diffs.push(values[i] - values[i - 1]);
                }

                const meanDiff = diffs.reduce((a, b) => a + b, 0) / diffs.length;
                const diffVariance = diffs.reduce((a, b) => a + Math.pow(b - meanDiff, 2), 0) / diffs.length;

                return {
                    mean: meanDiff,
                    variance: diffVariance,
                    regularity: diffVariance === 0 ? 1 : 1 / (1 + diffVariance)
                };
            }

            checkMovementLinearity(movements) {
                if (movements.length < 3) return 0;

                // 计算起点和终点
                const start = { x: movements[0].x, y: movements[0].y };
                const end = { x: movements[movements.length - 1].x, y: movements[movements.length - 1].y };

                // 计算直线距离
                const lineLength = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));

                // 计算实际路径长度
                let pathLength = 0;
                for (let i = 1; i < movements.length; i++) {
                    pathLength += Math.sqrt(
                        Math.pow(movements[i].x - movements[i - 1].x, 2) +
                        Math.pow(movements[i].y - movements[i - 1].y, 2)
                    );
                }

                // 计算直线性 (0-1, 1表示完全直线)
                return lineLength / pathLength;
            }

            detectTypingCorrections(keyPresses) {
                let corrections = 0;

                // 检查退格键使用
                const backspaceCount = keyPresses.filter(k => k.key === 'Backspace').length;
                if (backspaceCount > 0) {
                    corrections += Math.min(backspaceCount, 3); // 最多加3分
                }

                // 检查方向键使用
                const arrowKeysCount = keyPresses.filter(k =>
                    k.key === 'ArrowLeft' || k.key === 'ArrowRight' ||
                    k.key === 'ArrowUp' || k.key === 'ArrowDown'
                ).length;
                if (arrowKeysCount > 0) {
                    corrections += Math.min(arrowKeysCount, 2); // 最多加2分
                }

                return corrections;
            }

            // 验证流程
            tryPassiveVerification() {
                // 如果已经有足够高的分数，直接通过验证
                if (this.behaviorScore >= this.passingScore * 1.0) {
                    this.passVerification();
                    return;
                }

                // 如果分数中等，等待更多行为数据
                if (this.behaviorScore >= this.passingScore * 0.5) {
                    setTimeout(() => {
                        // 再次检查分数
                        if (this.behaviorScore >= this.passingScore) {
                            this.passVerification();
                        }
                    }, 3000);
                }
            }

            verifyHuman() {
                // 检查输入是否正确
                if (this.humanInput.value !== "我不是机器人") {
                    this.showError("请输入正确的验证文本");
                    return;
                }

                this.showLoading();

                // 模拟网络请求延迟
                setTimeout(() => {
                    // 综合评分
                    const finalScore = this.calculateFinalScore();

                    if (finalScore >= this.passingScore) {
                        this.passVerification();
                    } else {
                        this.showError("验证失败，您的行为模式不符合人类特征");
                    }
                }, 1500);
            }

            calculateFinalScore() {
                // 基础分数
                let finalScore = this.behaviorScore;

                // 输入正确的加分
                if (this.humanInput.value === "我不是机器人") {
                    finalScore += 10;
                } else {
                    finalScore -= 15; // 错误输入减分
                }

                // 检查是否有足够的行为数据
                if (this.behaviorData.mouseMovements.length < 10 ||
                    this.behaviorData.clicks.length < 3 ||
                    this.behaviorData.keyPresses.length < 5) {
                    finalScore -= 15; // 行为数据不足
                }

                // 确保分数在合理范围内
                return Math.max(0, Math.min(finalScore, this.maxScore));
            }

            // UI 控制方法
            showLoading() {
                this.verifyButton.disabled = true;
                this.loadingIndicator.style.display = 'block';
                this.errorMessage.style.display = 'none';
            }

            showError(message) {
                this.verifyButton.disabled = false;
                this.loadingIndicator.style.display = 'none';
                this.errorMessage.textContent = message;
                this.errorMessage.style.display = 'block';
            }

            passVerification() {
                this.verificationPassed = true;
                this.loadingIndicator.style.display = 'none';
                this.successMessage.style.display = 'block';
                this.verifyButton.style.display = 'none';
                this.humanInput.style.display = 'none';

                // ✅ 发送消息给父窗口（建议指定目标 origin）
                window.parent.postMessage(
                    { type: 'turnstileVerified', success: true },
                    window.location.origin  // 或者 '*'（不推荐，可能有安全问题）
                );

                // 3秒后关闭验证（可选）
                setTimeout(() => {
                    const event = new CustomEvent('turnstileVerified', {
                        detail: { success: true, score: this.calculateFinalScore() }
                    });
                    document.dispatchEvent(event);
                }, 2000);
            }

            // 公开方法
            getVerificationStatus() {
                return {
                    verified: this.verificationPassed,
                    score: this.calculateFinalScore(),
                    data: this.behaviorData
                };
            }
        }

        // 初始化验证
        document.addEventListener('DOMContentLoaded', () => {
            const turnstile = new TurnstileVerification();

            // 暴露API供外部调用
            window.Turnstile = {
                getStatus: () => turnstile.getVerificationStatus()
            };
        });
    </script>
</body>

</html>